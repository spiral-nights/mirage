# Technical Overview: The Nostr App Engine

## 1. Executive Summary

The Nostr App Engine is a client-side platform that enables the creation and execution of "serverless" micro-apps. These apps are generated by AI, stored as Nostr events, and executed within a secure, sandboxed browser environment.

The core innovation is a **"Virtual API"** layer. This abstracts the complexity of the Nostr protocol (relays, cryptography, NIPs) into standard RESTful endpoints. This allows an AI to generate a functional app by writing standard HTML/JS that purely consumes a `fetch()` API, unaware that the "backend" is actually a decentralized network.

---

## 2. System Architecture

The system utilizes a **Fetch Proxy** pattern to bridge the gap between the sandboxed app and the Nostr network while maintaining strict security boundaries.

### Component Diagram

```mermaid
graph TD
    subgraph "Parent Website (The Host)"
        A[Host UI]
        B[NIP-07 Signer / Keys]
    end

    subgraph "Sandboxed Iframe (User App)"
        direction TB
        C[AI-Generated HTML/JS]
        D[Injected Bridge (Main Thread)]
        E[Web Worker (The Engine)]
    end

    C -- "fetch('/api/feed')" --> D
    D -- "postMessage(req)" --> E
    E -- "Nostr Proto" --> F((Nostr Relays))
    
    %% Signing Flow
    E -. "Request Sign" .-> D
    D -. "Request Sign" .-> A
    A -. "Signature Only" .-> D
    D -. "Signature Only" .-> E

```

### The Three Layers

1. **The Host (Parent Website):**
* **Role:** The "Browser OS."
* **Responsibilities:** Loads the app event, manages the NIP-07 connection (keys), and enforces permissions.
* **Security:** This is the *only* layer with access to private keys or signing extensions.


2. **The Bridge (Injected Script):**
* **Role:** The "Interceptor."
* **Mechanism:** Monkey-patches `window.fetch`. It intercepts calls to the virtual `/api/` namespace and routes them via `postMessage` to the Web Worker.
* **Isolation:** Runs inside the iframe but acts as the gatekeeper.


3. **The Engine (Web Worker):**
* **Role:** The "Virtual Backend."
* **Responsibilities:** Maintains WebSocket connections to relays, serializes JSON to Nostr events, decrypts NIP-17 payloads, and manages local state.



---

## 3. The Virtual API Specification

The AI will be instructed to build apps using *only* these endpoints. This is the contract.

### A. Public & Social (Global State)

| Method | Endpoint | Description | Underlying NIP |
| --- | --- | --- | --- |
| `GET` | `/api/v1/user/me` | Returns current user profile (name, picture). | **NIP-01 (Kind 0)** |
| `GET` | `/api/v1/users/{pubkey}` | Returns profile for a specific user. | **NIP-01 (Kind 0)** |
| `GET` | `/api/v1/feed/global` | Returns recent text notes. | **NIP-01 (Kind 1)** |
| `POST` | `/api/v1/feed` | Publishes a public text note. | **NIP-01 (Kind 1)** |
| `POST` | `/api/v1/media` | Uploads file; returns URL. | **NIP-96** |
| `POST` | `/api/v1/zap` | Sends Lightning payment. | **NIP-57** |

### B. App Persistence (The "Database")

| Method | Endpoint | Description | Underlying NIP |
| --- | --- | --- | --- |
| `GET` | `/api/v1/storage/{key}` | Retrieves app-specific JSON data. | **NIP-78** |
| `PUT` | `/api/v1/storage/{key}` | Saves/Updates app-specific JSON data. | **NIP-78** |
| `GET` | `/api/v1/lists/{name}` | Retrieves a curated list (bookmarks, items). | **NIP-51** |

### C. Private & Shared (The "Family" Layer)

| Method | Endpoint | Description | Underlying NIP |
| --- | --- | --- | --- |
| `GET` | `/api/v1/groups` | Lists private groups the user is in. | **NIP-29** |
| `PUT` | `/api/v1/groups/{id}/storage` | Saves data visible *only* to group members. | **NIP-29 + NIP-78** |
| `POST` | `/api/v1/dm/{pubkey}` | Sends an encrypted direct message. | **NIP-17** |

---

## 4. Security Model: Zero-Knowledge App Layer

The guiding principle is **"The App Never Sees The Key."**

### 1. Origin Isolation

The app runs in an iframe with `srcdoc` and `sandbox="allow-scripts allow-forms"`. This forces a `null` origin. The app cannot access `localStorage`, cookies, or the parent DOM.

### 2. The Signing Handshake

When an app needs to sign an event (e.g., posting to the feed):

1. **App:** Calls `fetch('/api/feed', { method: 'POST', body: ... })`.
2. **Worker:** Constructs the unsigned event JSON.
3. **Worker -> Host:** Sends message `ACTION_SIGN_EVENT`.
4. **Host:**
* Checks the `meta` permissions of the app.
* *(Optional)* Prompts user: "App wants to post. Allow?"
* Calls `window.nostr.signEvent()`.


5. **Host -> Worker:** Returns the **Signature** (hex string).
6. **Worker:** Attaches signature, publishes to relays, resolves the original `fetch` promise.

### 3. Permissions Manifest

Every AI-generated app must include a meta tag defining its required scope.

```html
<meta name="nostr-permissions" content="public_read, storage_write, group_read">

```

The Host parses this on load. If the app attempts an API call outside this scope (e.g., trying to DM a stranger), the request is rejected immediately by the Bridge.

---

## 5. Implementation Strategy

### Phase 1: The Core Library (The "Engine")

* Build the Web Worker that wraps `nostr-tools`.
* Implement the `fetch` interceptor.
* Support basic NIP-01 (Feed) and NIP-07 (Signer).

### Phase 2: The Data Layer

* Implement NIP-78 (App Data) to give apps "memory."
* Implement NIP-30000s (Parameterized Replaceable Events) for storing the apps themselves.

### Phase 3: The Privacy Layer

* Implement NIP-17 (Gift Wraps) and NIP-29 (Groups) to enable the "Family Grocery List" use case.

